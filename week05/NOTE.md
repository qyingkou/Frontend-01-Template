## 周报

> 本周学习了语言的结构化知识。

1. 通过 xcode 的 object-c 实验，体验了 js 引擎是如何创建和使用的
1. 不同的js注入方式，会导致不同的外层调用。以下注入方式都是新的宏任务。
   1. script脚本
   1. script module  
1. 调用以下API将是宏任务
   1. 定时器
   1. addEventListener定义的回调

> 事件循环、宏任务和微任务  

事件循环是外层提供的运行机制，有别于一次性从头到尾的执行。  
事件循环负责收集队列项（宏任务），每一个宏任务中包含一个函数栈stack，只有当stack执行完毕清空了，那么该宏任务也完成。  
在es6规范之后，定义了微任务和微任务队列这个概念。微任务队列紧随调用它的宏任务执行，也就是说，宏任务的函数栈清空后宏任务结束之前，微任务队列开始执行。只有当微任务清空了，那么这个宏任务才算真正结束并进入下一个宏任务。  
事件循环机制、宏任务都是js语法之外的运行时提供的机制，但微任务则完全由语言自身来定义和控制。  
以下api的调用将产生微任务：  
1. MutationObserver
1. Promise.then(cb)

> 哪些任务是同步代码，哪些是异步的

由于微任务队列排在了宏任务函数栈之后，所以从时间上来说是微任务一定是异步的。  
宏任务就要分情况了：  
1. 若宏任务是同步的，且没有async和await的配合，那么该函数栈是同步的。
1. 若宏任务是同步的，有async和await的配合，那么await之后的那部分代码是异步的。  
1. 若宏任务是异步的，比如定时器被激活后产生的宏任务。那么所有函数栈中的代码都是异步的。  


> js的执行粒度总结（从大到小）
1. Js Context（js的引擎实例） // 既提供给宏任务全部变对象（用于数据共享），同时提供了一整套内置的数据类型集合（Realm）以供使用。  
1. 宏任务
1. 微任务
1. 函数调用
1. 语句/声明
1. 表达式
1. 直接量/变量/this等

> Realm（领域）
通过课堂实例，了解如何打印出所有的Realm

---

> 七层网络模型

(略)
> tcp和IP

(略)
> http

(略)
> 课堂作业

创建一个http服务，和一个tcp客户端，确保请求返回的传输类型是chunked。  
使用客户端实例的data事件，累加chunkBuff或者使用直接流式解析字符串，最终解析出所有的消息(与我们熟知的浏览器ajax接口类似）。包括：  
- status line 状态栏
   - statusCode
   - statusText
- headers 消息头
- body 消息体（因规定了chunked传输，所以只实现了chunk方式解析）

流式解析，最常用的是使用状态机方式解决。该方案使得状态之间可以切换，状态之内的条件分支相对简单，且容易维护。